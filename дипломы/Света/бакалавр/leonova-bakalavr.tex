\documentclass[12pt,a4paper]{report}

\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}
\usepackage{a4,cite,amsmath,amssymb,amsthm}
\usepackage[T2A]{fontenc}
\usepackage{amstext}
\usepackage{latexsym}
\usepackage{euscript}
\usepackage{mathrsfs}
\usepackage{graphicx}
\usepackage{geometry}
\geometry{left=3cm}
\geometry{right=2cm}
\geometry{top=1.5cm}
\geometry{bottom=2cm}

\newtheorem*{theorem}{Теорема}
\newtheorem*{definition}{Определение}

\begin{document}

\input{title-list.tex}

блабла

\newpage

\section*{\centering{РЕФЕРАТ}}

\medskip

Леонова С.И. РАЗРАБОТКА И ИССЛЕДОВАНИЕ АЛГОРИТМОВ ПОСТРОЕНИЯ ЭКСТРЕМАЛЬНЫХ ЦЕПЕЙ В ВЕРШИННО-ВЗЕШЕННЫХ ОРГРАФАХ. ЧАСТНЫЙ АЛГОРИТМ,

выпускная квалификационная работа на степень бакалавра наук : стр. 21, рис. 6, табл. 1, форм. 6, библ. 9 назв.

\medskip

Ключевые слова: АЛГОРИТМЫ, ОРИЕНТИРОВАННЫЕ ГРАФЫ, ПРОСТЫЕ ЦЕПИ, ГОРЯЧАЯ ПРОКАТКА

Объект исследования - ориентированные графы специального вида.

Цель работы - построение простых цепей максимального веса в вершинно-взвешенных ориентированных графах специального вида.

В процессе работы исследуется структура графов, возникающих при моделировании задачи планирования графиков горячей прокатки.
Разрабатываются алгоритмы поиска простых цепей максимального веса. Оценивается их сложность. Полученные результаты применяются для решения более общих задач в области планирования металлургического производства.



\newpage

\tableofcontents

\newpage



\chapter{Введение $\bar{w}(e) - w(h) = w(T) - w(T') \ge 0$}
\label{introduction}
В настоящей работе рассматриваются ориентированные графы специального вида. Эти графы возникают при математической постановке задачи построения графиков прокатки для металлургических предприятий. Ресурсом для прокатки металла являются так называемые \emph{партии} - металлические заготовки обладающие определеными геометрическими параметрами. \emph{График прокатки} представляет собой упорядоченный набор партий, прокатываемых на стане горячей прокатки. Для получения качественного металла необходимо соблюдать ряд ограничений на порядок следования партий друг за другом. Таким образом, график прокатки должен удовлетворять всем технологическим ограничениям и при этом обладать "хорошим" сочетанием показателей по ряду критериев оценки. В настоящей работе в качестве критерия выбрана максимальная суммарная длина прокатанных рулонов.
\newline
В ряде работ (например, \cite{BeVaLe_ReviewStellProduction},
\cite{BeVaLe_IntegrContCasterAndRolling}) приведены практические постановки задач совместного планирования
непрерывной разливки стали и последующей горячей прокатки. Подробно обсуждаются различные варианты организации
работы предприятия, когда разлитый металл полностью остывает, прежде, чем идет в нагревательные печи и на прокатку,
либо остывает частично в виду наличия транспортного плеча, остывает мало и идет, как принято говорить на отечественных
предприятиях, в прокатку горячим садом. Иллюстрируется эффект энергосбережния и прочее. Также в работах приводятся
основные технологические ограничения, связанные с формиров
анием графиков прокатки, которые используются в аналогичных
условиях большинством предприятий. Приводятся некоторые математические модели, используемые при расчете графиков
прокатки, для таких задач в иностранной литературе приняты названия "hot strip mill planning" и
HRBPPs (hot rolling batch planning problems).
\newline
Приводимые в работах модели представляют собой аналоги и обобщения
задач коммивояжера TSP (Travelling Salesman Problem) и  планирования маршрутов транспорта VRT
(vehicle routing problem, \cite{BeVaLe_Dantzig_Ramser}).
Существуют модели PCTSP (Prize Collecting TSP), предложенная Балашем (\cite{BeVaLe_PCTSP_Balas}, \cite{BeVaLe_Bals}) и PCVRP
(Prize Collecting VRP, \cite{BeVaLe_Liu}), в которых для каждой пары партий прокатки задана стоимость перехода с
одной на другую, то есть стоимость того, что в графике прокатки они непосредственно следуют друг за другом.
Также задается награда (приз) за то, что партия входит в построенный график прокатки, и возможнен штраф за невхождение партии в
график прокатки. Результатом является построение графиков с максимизацией получаемых призов, за вычетом штрафов за переходы с одной партии на другую.
\newline Указанные задачи являются в общем случае труднорешаемыми.

Учитывая специфичный способ описания ограничений предшествования партий в графике прокатки, принятый
на отечественных предприятиях (например, ОАО "ММК"), ограничения удобно представлять в виде ориентированного графа. Предлагается удалить из целевой функции составляющую штрафов за переход, а сами переходы отнести в состав ограничений.
Таким образом, задача построения графиков прокатки в своих базовых ограничениях сводится к задаче поиска простой цепи достаточно большого веса в вершинно-взвешенном ориентированном графе. Смежность узлов в этом графе задается соотношением между ширинами и толщинами последовательно
прокатываемых партий.
\newline Основным результатом является то, что благодаря такому способу задания смежности удается построить алгоритм для нахождения простой цепи (графика прокатки) максимального веса, сложность которого ограничена кубом числа узлов (партий). Хотя в общем случае задача поиска
простой цепи максимального веса труднорешаема.
\newline Созданный алгоритм используется для оперативного планирования на станах прокатки в некоторых цехах ОАО "ММК".

Поясним причину выбора критерия оптимизации. Оценки графиков прокатки связаны с особенностями организации
производства на конкретном предприятии. Вместе с тем общим является то, что график прокатки должен содержать
достаточно таких партий, чтобы суммарный вес/длина партий были достаточно велики. Более того, наличие "большого"
технологически допустимого графика прокатки позволяет на следующем этапе в автоматическом или ручном режиме его
отредактировать, чтобы получить желаемый результат по всей совокупности практических требований. Также в качестве
веса партии может выступать величина, характеризующая не только ее физические характеристики, но и предпочтительность
по срокам, видам продукции и т.п. По указанным причинам для получения оптимизационной постановки задачи естественно
потребовать максимальности суммарного веса партий, входящих в график прокатки.

\newpage

\chapter{Постановка задачи}
\label{formulation}
Обозначим через $P$ множество партий $\{p_1, p_2, \dots, p_k\}$, где $k \in \mathbb{N}$.
\newline
Пусть

\begin{itemize}
\item $w: P \rightarrow \mathbb{R}^+$ --- ширина партии;
\item $t: P \rightarrow \mathbb{R}^+$ --- толщина партии;
\item $l: P \rightarrow \mathbb{R}^+$ --- длина партии; Для удобства в дальнейшем будем называть её весом, таким образом, $l$ - весовая функция.
\item $r: \mathbb{R}^+ \rightarrow \mathbb{R}^+$ --- монотонно неубывающая функция, определяющая максимальную величину допустимой разности значений толщины между двумя соседними партиями;
\item $\mathbb{W} \in \mathbb{R}^+$ --- величина, определяющая максимальную величину допустимой разности значений ширины между двумя соседними партиями.
\end{itemize}

Геометрические параметры партий являются основным источником накладываемых ограничений на порядок следования партий друг за другом в графике прокатки.
\newline
Партия $q$ может непосредственно следовать за партией $p$ в графике прокатки в том и только в том случае, когда выполнены:
\begin{enumerate}
\item ограничение "для перехода по толщине":
\begin{equation}\label{width_constr} |t_p - t_q| \le \min\{r(t_p), r(t_q)\} \end{equation}

\item ограничение "для перехода по ширине":
\begin{equation}\label{thick_constr} 0 \le w_p - w_q \le \mathbb{W} \end{equation}

\end{enumerate}

Пусть $G$ ориентированный граф на множестве узлов $P$ с множеством дуг $E \subseteq P\times P$ таким, что
$pq \in E$ в том и только в том случае, когда партии $p$ и $q$ различны, и $q$ может непосредственно следовать
за $p$ в графике прокатки.

Множество всех допустимых графиков прокатки совпадает со множеством $\mathbb{B}(G)$ всех простых цепей в $G$.

Для простой цепи $z$ через $l(z)$ обозначим её вес:

\begin{equation}\label{path_weight} l(z) \triangleq \displaystyle\sum_{p \in P(z)} l(p) \end{equation}

Сформулируем {\bf задачу} оптимизации --- найти в $\mathbb{B}(G)$ цепь максимального веса:

\begin{equation} \label{problem} l(z) \rightarrow \displaystyle \max \mbox{, где} \;z \in \mathbb{B}(G) \end{equation}

\newpage
Пусть $p$ - произвольный узел в $G$. Обозначим через:
\begin{itemize}

\item $W = \{w_p| p \in P\}$ - всевозможные значения ширин узлов
\item $P_w = \{p | w_p = w\}$, где $w \in W$, - множество узлов, имеющих данную ширину $w$.
\item $G_w$ - граф, индуцированный множеством $P_w$.
\end{itemize}


Заметим, что любая наибольшая по весу простая цепь является максимальной по включению узлов. Поэтому для решения задачи \ref{problem} достаточно искать наибольшую по весу цепь среди максимальных по включению узлов цепей.

Таким образом, задача поиска наибольшей по весу цепи сводится к следующей задаче :

\begin{equation} \label{newproblem} l(z) \rightarrow \displaystyle \max \mbox{,} \;z \in \mathbb{C}(G) \end{equation}

где $\mathbb{C}(G)$ - множество максимальных по включению узлов простых цепей в графе $G$.

В данной работе задача \ref{newproblem} решается для графа $G_w$.

Ниже будет приведен частный алгоритм решения задачи :

\begin{equation} \label{locproblem} l(z) \rightarrow \displaystyle \max \mbox{, где} \;z \in \mathbb{C}(G_w) \end{equation}

где $z$ - цепи с фиксированным началом $s$ и фиксированным концом $e$.

\newpage

\chapter{Метод решения}
\label{method}
Для эффективного решения задачи предложен следующий подход :
\begin{enumerate}
\item Разрабатывается алгоритм, состоящий из двух частей - алгоритм, решающий задачу в подграфах $G_w$ и общий алгоритм, решающий задачу, в графе $G$. В настоящей работе рассматривается частный алгоритм для поиска максимальной простой цепи в графе $G_w$. Данный алгоритм используется в качестве подпрограммы для поиска максимальной простой цепи в графе $G$. Описание общего алгоритма приведено в работе \cite{berez}.

\item Проводится анализ сложности алгоритма.

\item Приводятся результаты тестов и их анализ.
\end{enumerate}

\newpage

\chapter{Частный алгоритм поиска цепи максимального веса}
\label{algorytm}

\section{Анализ структуры графа}
\label{analys}
Для лучшего понимания структуры графа и удобства разработки алгоритма придуман удобный и естественный способ укладки графа на плоскости. Геометрические характеристики узлов выступают в роли координат. Для визуализации разработан плагин укладки для открытой программы Gephi.

\begin{figure}[h!]
\centering
\includegraphics[width=320px]{graph_fragment.eps}
\caption{Структура графа}
\label{graph_fragment}
\end{figure}
На рис. (\ref{graph_fragment}) изображен фрагмент графа.

По оси абсцисс откладывается толщина узлов, по оси ординат откладывается ширина узлов, начало координат находится в левом нижнем углу.
Видно, что граф складывается из подграфов $G_w$ таким образом, что дуги между подграфами направлены только вниз. Это обеспечивается условием предшествования партий по ширине. Внутри любого подграфа $G_w$ для каждой пары вершин $p, q \in P_w$ из существования дуги $pq$ следует существование обратной дуги $qp$. Эта симметрия обеспечивается модулем в условии предшествования по толщине. Также симметрия означает наличие циклов в подграфах $G_w$, что делает попытку решения задачи перебором крайне неэффективной.
В данной работе речь пойдет о решении задачи в графах вида $G_w$.

\newpage

\section{Неформальное описание алоритма}
\label{no_formal}

Пусть заданы $w \in W$ и $s, e \in P_w$.

Алгоритм возвращает простую цепь $H = (q_1, q_2, \ldots, q_n)$, что $s = q_1 \rightarrow q_2 \rightarrow \ldots \rightarrow q_n = e$ -

\begin{itemize}
\item единственная максимальная по включению узлов $(s, e)$ - цепь для заданной ширины $w$, если $t_s\not= t_e$,
\item максимальная по весу $(s, e)$ - цепь из двух максимальных по включению цепей для заданной ширины $w$, если $t_s = t_e$,
\item сообщение, что простой $(s,e)$-цепи не существует.
\end{itemize}

Алгоритм заключается в последовательном добавлении узлов из множества $P_w$ в простую цепь $H$.

Рассмотрим случай, когда $t_s \not= t_e$. Пусть для определенности $t_s < t_e$. Множество $P_w \setminus \{s, e\}$ делится на три множества : $H^-, H^+, H^0$, где $H^-$ - узлы, имеющие толщину меньшую, чем у $s$. $H^+$ - узлы, имеющие толщину большую, чем у $e$. $H^0$ - все остальные узлы. Нетрудно видеть, что любой узел $p$ такой, что $t_s \le t_p \le t_e$, то есть узел из $H^0$, обязательно должен содержаться в максимальной по включению узлов $(s, e)$ - цепи. Поэтому изначально строится такая цепь : $H' = (s = p_1, p_2, \ldots, p_k = e)$, где $t_{p_1} \le t_{p_2} \le \ldots \le t_{p_k}$. Если существует такой номер $i$, что не существует дуги $p_ip_{i+1}$, значит такую цепь $H'$ построить нельзя, следовательно простой $(s,e)$-цепи не существует.

\begin{figure}[h!]
\centering
\includegraphics[width=320px]{p1.eps}
\caption{Разбиение по толщине}
\label{p1}
\end{figure}

Далее попытаемся добавить в $H'$ узлы из $H^-$. Выберем из этого множества узел $q_1$ с наибольшим значением толщины. Если существуют дуги $sq_1$ и $q_1p_2$, значит этот узел можно добавить в $H'$.



 \begin{figure}[h!]
\centering
\includegraphics[width=320px]{p2.eps}
\caption{Добавление узла из $H^-$}
\label{p2}
\end{figure}

\newpage

Затем в множестве $H^-\setminus\{q_1\}$ выбираем наибольший по толщине узел $q_2$. Если это возможно, добавляем его между узлами $s$ и $q_1$ или между $q_1$ и $p_2$, выбирая из них ту пару, чья разность по толщине наименьшая.

   \begin{figure}[h!]
\centering
\includegraphics[width=320px]{p3.eps}
\caption{Добавление следующего узла из $H^-$}
\label{p3}
\end{figure}

Процесс завершится, если будут просмотрены все узлы из $H^-$ или в тот момент, когда на каком то шаге не удастся добавить узел в цепь. Это будет означать, что и все оставшиеся (меньшие по тощине) узлы так же не смогут быть добавлены.

После добавления узлов из $H^-$ получилась цепь $H''$. В нее попытаемся добавить узлы из $H^+$. Аналогично выбирается узел $r_1$ из $H^+$ с наименьшим значением толщины. Если существуют дуги $p_{k-1}r_1$ и $r_1e$ до узел $r_1$ добавляется в цепь и так далее пока не будут просмотрены все узлы из $H^+$ или пока в какой-то момент невозможно будет добавить узел из $H^+$ в текущую цепь.

\begin{figure}[h!]
\centering
\includegraphics[width=320px]{p4.eps}
\caption{Добавление узла из $H^+$}
\label{p4}
\end{figure}

\newpage

Пусть $t_s = t_e$. Если при этом множество $H^0$ не пусто, то данный случай аналогичен тому, что описан выше. Если $H^0$ пуст, то первыми элементами, между которыми будет вставляться наибольший по толщине узел из $H^-$ будут $s$ и $e$. Между ними же будет вставляться наименьший по толщине узел из $H^+$.


\begin{figure}[h!]
\centering
\includegraphics[width=320px]{p5.eps}
\caption{Две максимальные по включению узлов цепи}
\label{p5}
\end{figure}

Поэтому сначала добавляются узлы из $H^-$, затем из $H^+$, после чего получается первая максимальная по включению узлов цепь $H_1$. Затем к цепи $s \rightarrow e$ добавляются сначала узлы из $H^+$, затем из $H^-$, после чего получается вторая максимальная по включению узлов цепь $H_2$. И среди цепей $H_1$ и $H_2$ выбирается наибольшая по длине.

\newpage

\section{Формальное описание алоритма}
\label{formal}
Пусть $H = (p_1, p_2, \ldots, p_l)$ - произвольная простая цепь, где $l > 2$.

Пусть $i$ такой, что $p_i = \arg \displaystyle\max_{p \in H} t_p$. Если $1 < i < l$, то {\it правой дугой} назовем дугу $p_ip_{i+1}$, если $t_{p_{i+1}} \ge t_{p_{i-1}}$ , иначе дугу $p_{i-1}p_i$. Если $i = 1$, то {\it правой дугой} будет дуга $p_ip_{i+1}$. Если $i = l$, то {\it правой дугой} будет дуга $p_{i-1}p_{i}$.

Аналогично {\it левой дугой} $H$ назовем дугу $p_ip_{i+1}$, если $t_{p_{i+1}} \le t_{p_{i-1}}$, иначе дугу $p_{i-1}p_i$, где $p_i = \arg \displaystyle\min_{p \in H} t_p$ и $1 < i < l$. Если $i = 1$, то {\it левой дугой} будет дуга $p_ip_{i+1}$. Если $i = l$, то {\it левой дугой} будет дуга $p_{i-1}p_{i}$.

{\bf Частный алгоритм построения максимальной по весу простой цепи в графе $G_w$}.



\begin{enumerate}
\item Пусть

$H_{0} = (p_1, p_2, \ldots p_k)$, где $p_i \in P_w$ и $\forall i : t_s \le t_{p_i} \le t_{p_{i+1}} \le t_t$.

$H^{+}_{0} = \{p | t_p > t_t\}$.

$H^{-}_{0} = \{p | t_p < t_s\}$.

\item Проверить условие : $\forall i : p_i, p_{i+1} \in H_{0} \Rightarrow p_ip_{i+1} \in E$.

    Если оно не выполнено, то нельзя построить путь максимальной длины.
\item Если $|H_{0}| > 2$, то
    \begin{enumerate}
        \item\label{l1} Пусть $i = 0$.

        Пока $H^{+}_i \not = \emptyset$
            \begin{itemize}
                \item $q_i = \arg \displaystyle \min_{q\in H^{+}_i} t_q$, $p^{i}_jp^{i}_{j+1}$ - правая дуга $H_i = (p^{i}_1, p^{i}_2, \ldots, p^{i}_{n_i})$
                \item Если $p^{i}_jq_i \in E$ и $q_ip^{i}_{j+1} \in E$, то

                        $H^{+}_{i+1} = H^{+}_i\setminus \{q_i\}$,

                        $H_{i+1} = (p^{i}_1, p^{i}_2, \ldots, p^{i}_j, q_i, p^{i}_{j+1}, \ldots, p^{i}_{n_i})$

                     Иначе $H^{+}_{i+1} = \emptyset$,

                     $i = i + 1$;
            \end{itemize}

        \item\label{l2} Пусть $k = i, i  = 0$.

        Пока $H^{-}_i \not = \emptyset$
            \begin{itemize}
                \item $q_i = \arg \displaystyle \max_{q\in H^{-}_i} t_q$, $p^{i}_jp^{i}_{j+1}$ - левая дуга $H_i = (p^{i}_1, p^{i}_2, \ldots, p^{i}_{n_i})$
                \item Если $p^{i}_jq_i \in E$ и $q_ip^{i}_{j+1} \in E$, то

                        $H^{-}_{i+1} = H^{-}_i\setminus \{q_i\}$,

                        $H_{k + i+1} = (p^{k + i}_1, p^{k + i}_2, \ldots, p^{k + i}_j, q_i, p^{k + i}_{j+1}, \ldots, p^{k + i}_{n_i})$,

                 Иначе $H^{-}_{i+1} = \emptyset$,

                 $i = i+1$;
            \end{itemize}

         \item $H = H_{i + k}$ - максимальная по включению узлов Цепь.
    \end{enumerate}
\item Если $|H_0| = 2$, то имеет значение, какой из списков $H^{+}$ или $H^{-}$ первым добавлять в $H$. Поэтому сначала выполняются пункты \ref{l1}, \ref{l2}. Затем выполняются сначала \ref{l2}, а затем \ref{l1}. После чего получаются две максимальные по включению цепи. (Из них выбирается максимальная по длине).

\item В случае $s=t$ максимальная по длине простая цепь состоит из одного элемента $s$.

\end{enumerate}

\begin{theorem}[{\bf1}] Частный алгоритм строит максимальную по включению цепь.
\end{theorem}
\begin{proof}
\begin{enumerate}
    \item Пусть $H$ - цепь, построенная по алгоритму 1, а $H_m$ - максимальная по включению цепь. Предположим, $H$ - не максимальна, то есть существуют узлы из $H_m$, которые не попали в $H$.
    \item Понятно, что если $\exists p \in H_m\setminus H$, то $t_p \not \in [t_s, t_t]$, т. к. в противном случае $p$ обязательно попадет в $H$.
    \item Пусть $p'p''$ -  правая дуга цепи $H$. И пусть для определенности $t_{p''} \ge t_{p'}$. Тогда в силу построения $H$ и определения правой дуги справедливо равенство $t_{p'} = \displaystyle \max_{p\in H\setminus\{p''\}} t_p$.
    \item Рассмотрим множества $V^{+} = \{p| p \in H_m\setminus H, t_p > t_t\}$, $V^{-} = \{p| p \in H_m\setminus H, t_p < t_s\}$. Пусть $V^{+}$ не пусто и $q = \arg \displaystyle \min_{p\in V^{+}} t_p$. Покажем, что $q$ можно включить в $H$.
    \item  Заметим, что $H_m = V^- \cup H \cup V^+$. В силу того, что $H_m$ - цепь из $s$ в $t$, найдутся дуги из множества $V^{-}\cup H$ в $V^{+}$ и обратно. То есть найдутся узлы $v_1, v_2 \in V^{-}\cup H$ и $u_1, u_2 \in V^{+}$, что дуги $v_1u_1$ и $u_2v_2$ содержатся в $H_m$.

    \item  Из того, что $v_1u_1 \in H_m$ следует, что расстояние между $t_{v_1}$ и $t_{u_1}$ достаточно мало. Но расстояние между $t_{v_1}$ и $t_q$ еще меньше, поэтому дуга $v_1q \in E$. Аналогично, дуга $qv_2 \in E$.

     \item В силу определения правой дуги расстояние до $t_q$ уменьшится, если заменить $v_1$ на $p'$, а $v_2$ на $p''$, то есть $p'q \in E$ и $qp'' \in E$. Тогда $q$ можно включить в $H$ по алгоритму.


     \item Таким образом, любой элемент из $V^{+}$, так же как и любой элемент из $V^{-}$, можно включить в $H$.
     \item Следовательно, $H$ - максимальная по включению узлов цепь. В силу пункта 4 алгоритма будет построена максимальная по длине цепь.
\end{enumerate}
\end{proof}


\begin{theorem}[{\bf2}] Частный алгоритм имеет сложность $O(n\log n)$, где $n = |P_w|$.
\end{theorem}
\begin{proof}
Список узлов в заданной ширине $w$ сортируется по толщине за $O(n\log n)$. После чего, в худшем случае, каждый узел из $P_w$ будет просмотрен один раз. Таким образом, сложность всего алгоритма остается $O(n\log n)$.
\end{proof}


\newpage

\chapter{Программная реализация}

В работе использован язык программирования Java.

\section{Используемые структуры данных}

В программе были реализованы следующие структуры данных :

\begin{itemize}
\item Вершина графа, хранящая информацию о ширине, толщине и длине партии

class Vertex

\{

    ...

{\parindent=1cm    double width;

    double thickness;

    double length;}

    ...

\}

\item Критерий непосредственного следования партий друг за другом в графике прокатки

class HotCrit

\{

    ...

 {\parindent=1cm   double w;

    double r(thickness);

    boolean widthCrit(from, to);

    boolean thicknessCrit(from, to);

    boolean test(from, to);}

    ...

\}

Величина w и функция r известны из ограничений. Методы widthCrit(from, to) и thicknessCrit(from, to) проверяют, удовлетворяют ли партии from и to ограничениям для переходов "по ширине" и "по толщине" соответственно. Метод test(from, to) проверяет, может ли партия to следовать за партией from в графике прокатки.

\item Простая цепь, представленная набором узлов path, с началом в узле start, концом в узле end и длиной length

class Path

\{

...

{ \parindent=1cm   Vertex start;

	Vertex end;

	ArrayList<Vertex> path;

    double length;}

...

\}


\end{itemize}
\newpage
\section{Методы}


На входе алгоритма заданы :
\begin{enumerate}

\item Vertex start - начало пути;

\item Vertex end - конец пути;

\item ArrayList<Vertex> vertex - список упорядоченных по возрастанию значений толщины узлов в заданной ширине;
\end{enumerate}

\begin{itemize}

\item Метод divide формирует три списка :

before - упорядоченный по убыванию значений толщины список узлов, меньших по толщине, чем start

between - упорядоченный по возрастанию толщины список узлов, толщина которых не меньше, чем толщина start, и не больше, чем толщина end

after - упорядоченный по возрастанию толщины список узлов, толщина которых больше, чем толщина end

\item Метод addBefore добавляет в текущий путь узлы из списка before.

\item Метод addAfter добавляет в текущий путь узлы из списка after.

\item Метод layerPath принимает на вход start, end, vertex и критерий crit. Возвращает наибольшую по длине (start, end) - простую цепь.

layerPath (vertex, start, end, crit)

\{

    	ArrayList<Vertex> path = new ArrayList<Vertex>();

        ...

     {\parindent=1cm   divide(vertex, start, end, before, between, after);

		path.addAll(between);

        addBefore(before, path, crit);

        addAfter(after, path, crit);}

        ...

\}

\end{itemize}
\newpage
\section{Инструкция пользователю}
\label{instrution}

 Входной файл представлен списком партий, имеющих одинаковую ширину, и двумя узлами - началом и концом пути. Партии задаются тремя действительными числами - шириной, толщиной и длиной (весом).
 Пример:
\begin{enumerate}
\item 1280	2,4	4,806 - начальный узел
\item 1280	2	6,283 - конечный узел
\end{enumerate}

\begin{enumerate}
\item 1280	2,4	4,806
\item 1280	2	6,283
\item 1280	2,8	2,352
\item 1280	2	1
\item 1280	2	5,23
\item 1280	2	9,153
\item 1280	3	0,856
\item 1280	2,8	1,08
\end{enumerate}

Выходной файл содержит длину построенной цепи, последовательность узлов, вошедших в данную цепь, и их количество.
 Пример:

 30.76000000000001	

 (1, 8, 7, 3, 6, 5, 4, 2)

 8

\newpage

\section{Результаты экспериментов}


Данные для тестов берутся из корпоративной сети ОАО "ММК".

Критерии непосредственного следования партий друг за другом определяются следующим образом :

\begin{enumerate}
\item Величина $\mathbb{W}$ для "перехода по ширине" равна 250 мм;
\item Функция $r$ для "перехода по толщине" задается следующим образом :

\begin{equation}
r(t) = \begin{cases}
0.8 ,&\text{если $1.29 \le t \le 2.0$;}\\
1.5 ,&\text{если $2 < t \le 3.0$;}\\
2 ,&\text{если $3 < t \le 16.0$;}\\
4 ,&\text{если $16 < t \le 20.0$.}
\end{cases}
\end{equation}
\end{enumerate}

Генерируются выборки порядка 200-300 партий. Из заданной выборки для каждого значения ширины генерируются списки узлов этой ширины. И для каждой пары узлов из списка партий в одной ширине строятся максимальные по весу простые цепи.

Ниже приведена таблица, в которой показано отношение количества узлов в максимальной цепи к общему количеству узлов в одной ширине. Нетрудно видеть, что обычно алгоритм генерирует цепи, содержащие больше 70 процентов от общего числа узлов. Данные, по которым составлена таблица, приведены в приложениях.

\begin{figure}[h!]
\centering
\includegraphics[width=400px]{table.eps}
\end{figure}

Важным результатом является высокая скорость работы алоритма, так как он запускается многократно.
\newpage

\chapter*{Заключение}
\addcontentsline{toc}{chapter}{Заключение}
\label{conclusion}
Автоматическое планирование металлургического производства является сложной задачей, которая до сих пор не реализована полностью ни на одном предприятии в мире. Сопутствующие ей математические постановки зачастую являются труднорешаемыми. За счет исследования технологических ограничений на конкретном предприятии удалось сформулировать математическую задачу планирования графика прокатки. В настоящей работе разработан полиномиальный алгоритм решения сотпутствующей подзадачи, существенно использующийся в общем алгоритме. Удалось разработать полиномиальный алгоритм решения общей задачи. Результат уже частично внедрён и продолжается внедрятся на ОАО "ММК". В реальной жизни существуют более общие и сложные постановки задачи планирования графиков прокатки, решение которых основывается на описанных в настоящей работе алгоритмах.
\newpage

\small

\addcontentsline{toc}{chapter}{Список литературы}
\begin{thebibliography}{50}
\bibitem{berez} Березин А. А. Разработка и исследование алгоритмов построения экстремальных цепей в вершинно-взвешенных орграфах. Общий алгоритм.
\bibitem{BeVaLe_ReviewStellProduction} Lixin Tang, Jiyin Liu, Aiying Rong, Zihou Yang. A review of
planning and scheduling systems and methods for integrated steel production. European Journal of
Operational Research. Volume 133, Issue 1, 16 August 2001, PP. 1–20.
\bibitem{BeVaLe_IntegrContCasterAndRolling} P. Cowling, W. Rezig. Integration of continuous caster and hot strip
mill planning for steel production. Journal of Scheduling, Volume 3, Issue 4, July/August 2000, PP. 185–208.
\bibitem{BeVaLe_PCTSP_Balas} E. Balas, The prize collecting travelling salesman problem, Networks 19 (1989) 621-636.
\bibitem{BeVaLe_Bals} E. Balas and H. M. Clarence. Combinatorial optimization in steel rolling.
Workshop on Combinatorial Optimization in Science and Technology, April, 1991.
\bibitem{BeVaLe_Liu} Shixin Liu. Model and Algorithm for Hot Rolling Batch Planning in Steel Plants.
International Journal of Information and Management Sciences. 21 (2010), PP. 247-263.
\bibitem{BeVaLe_Dantzig_Ramser} G. B. Dantzig and J. H. Ramser. Management Science, Vol. 6, No. 1 (Oct., 1959), pp. 80-91.
\bibitem{BeVaLe_PCVRP_MDep_NLCost} Andreas Stenger, Michael Schneider, Dominik Goeke.
The prize-collecting vehicle routing problem with single and multiple depots and non-linear cost.
EURO Journal on Transportation and Logistics, May 2013, Volume 2, Issue 1-2, pp 57-87.
\bibitem{BeVaLe_Coco} K. Ioannidou, S. D. Nikolopoulos. The Longest Path Problem is Polynomial on
Cocomparability Graphs. Algorithmica. January 2013, Volume 65, Issue 1, pp 177-205.

\end{thebibliography}

\chapter*{Приложение}
\addcontentsline{toc}{chapter}{Приложение}
\label{app}

\section*{Данные}

Ниже приведена выборка, на основе который были проведены тесты.

1829	9,27	2,179

1829	9,27	0,622

1829	4,5	0,321

1829	4,5	1,603

1829	6,1	1,419

1829	4,55	0,634

1829	4,45	4,862

1829	6,1	0,709

1829	4,5	3,847

1829	6,1	4,02

1829	6,1	0,236

1829	6,1	2,128

1829	4,55	0,317

1820	6	0,483

1820	6	2,416

1820	5	2,61

1820	4	2,175

1820	6	2,9

1800	8	0,531

1800	6	0,708

1800	5	0,85

1800	4	1,063

1800	8	1,88

1800	9,99	0,851

1700	5	0,587

1700	5	1,469

1700	2,1	4,215

1700	5	0,472

1700	2,1	7,377

1700	2,1	3,162

1700	3,3	0,716

1550	3,9	0,718

1550	12	0,318

1550	10	0,198

1550	3,5	3,635

1550	3,5	2,909

1250	5	0,894

1250	2	2,528

1250	2	1,609

1250	2,8	12,211

1250	2,8	12,211

1250	2,8	12,211

1250	2,8	10,333

1250	2	1,267

1250	2	1,018

1250	5	0,447

1250	7	0,58

1115	3,8	3,842

1115	3,35	11,767

1115	3,35	8,281

1115	3,35	1,743

1115	3,35	8,281

1115	3,35	10,024

1115	3,35	0,872

1115	3,35	6,973

1060	4,5	2,431

1060	4,5	0,617

1060	3,9	3

1060	3,9	3,687

1060	3,5	0,794

1060	3,5	0,794

1060	4,2	0,618

1060	5,8	0,524

1060	5,8	2,098

1060	4,8	7,922

1060	4,2	0,372

1060	4,2	1,601

1055	3,9	0,741

1055	3,9	7,409

1055	2	14,661

1055	2	6,527

1055	3,3	2,537

1055	2,8	1,449

1055	2	6,527

1055	2,5	1,623

\newpage

\section*{Исходный код}

\subsection*{Примеры структур данных}

Реализация класса Vertex

\begin{figure}[h!]
\centering
\includegraphics[width=320px]{vertex.eps}
\end{figure}

Реализация класса Crit

\begin{figure}[h!]
\centering
\includegraphics[width=400px]{crit.eps}
\end{figure}

Реализация класса Path

\begin{figure}[h!]
\centering
\includegraphics[width=400px]{path.eps}
\end{figure}

\newpage

\subsection*{Примеры методов}

Реализация методов addBefore, addAfter и divide

\begin{figure}[h!]
\centering
\includegraphics[width=400px]{addBefore.eps}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=400px]{addAFter.eps}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=400px]{divide.eps}
\end{figure}

\newpage

Реализация частного алгоритма

\begin{figure}[h!]
\centering
\includegraphics[width=400px]{layer1.eps}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=350px]{layer2.eps}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=400px]{layer3.eps}
\end{figure}

\end{document} 