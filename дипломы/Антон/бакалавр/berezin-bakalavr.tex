\documentclass[12pt,a4paper]{report}

\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}
\usepackage{a4,cite,amsmath,amssymb,amsthm}
\usepackage[T2A]{fontenc}
\usepackage{amstext}
\usepackage{latexsym}
\usepackage{euscript}
\usepackage{mathrsfs}
\usepackage{graphicx}
\usepackage{geometry}
\geometry{left=3cm}
\geometry{right=2cm}
\geometry{top=1.5cm}
\geometry{bottom=2.0cm}

\newtheorem*{theorem}{Теорема}
\newtheorem*{definition}{Определение}

\begin{document}
\input{title-list.tex}% это титульный лист
\newpage

Эта страница появилась здесь, потому что я не умею нормально нумеровать страницы в TeX

\newpage

\section*{\centering{РЕФЕРАТ}}

\medskip

Березин А.А. РАЗРАБОТКА И ИССЛЕДОВАНИЕ АЛГОРИТМОВ ПОСТРОЕНИЯ ЭКСТРЕМАЛЬНЫХ ЦЕПЕЙ В ВЕРШИННО-ВЗЕШЕННЫХ ОРГРАФАХ. ОБЩИЙ АЛГОРИТМ,

выпускная квалификационная работа на степень бакалавра наук: стр. 21, рис. 4, табл. 1, форм. 14, библ. 10 назв.

\medskip

Ключевые слова: АЛГОРИТМЫ, ОРИЕНТИРОВАННЫЕ ГРАФЫ, ПРОСТЫЕ ЦЕПИ, ГОРЯЧАЯ ПРОКАТКА

Объект исследования --- ориентированные графы специального вида.

Цель работы --- построение простых цепей максимального веса в вершинно-взвешенных ориентированных графах специального вида.

В процессе работы исследуется структура графов, возникающих при моделировании задачи планирования графиков горячей прокатки.
Разрабатываются алгоритмы поиска простых цепей максимального веса. Оценивается их сложность. Полученные результаты применяются для решения более общих задач в области планирования металлургического производства.

\newpage

\tableofcontents

\newpage

\chapter{Введение}
\label{introduction}
В настоящей работе рассматриваются ориентированные графы специального вида. Эти графы возникают при математической постановке задачи построения графиков прокатки для металлургических предприятий. Ресурсом для прокатки металла являются так называемые \emph{партии} --- металлические заготовки обладающие определеными геометрическими параметрами. \emph{График прокатки} представляет собой упорядоченный набор партий, прокатываемых на стане горячей прокатки. Для получения качественного металла необходимо соблюдать ряд ограничений на порядок следования партий друг за другом. Таким образом, график прокатки должен удовлетворять всем технологическим ограничениям и при этом обладать "хорошим" сочетанием показателей по ряду критериев оценки. В настоящей работе в качестве критерия выбрана максимальная суммарная длина прокатанных рулонов.
\newline
В ряде работ (например, \cite{BeVaLe_ReviewStellProduction},
\cite{BeVaLe_IntegrContCasterAndRolling}) приведены практические постановки задач совместного планирования
непрерывной разливки стали и последующей горячей прокатки. Подробно обсуждаются различные варианты организации
работы предприятия, когда разлитый металл полностью остывает, прежде, чем идет в нагревательные печи и на прокатку,
либо остывает частично в виду наличия транспортного плеча, остывает мало и идет, как принято говорить на отечественных
предприятиях, в прокатку горячим садом. Иллюстрируется эффект энергосбережния и прочее. Также в работах приводятся
основные технологические ограничения, связанные с формированием графиков прокатки, которые используются в аналогичных
условиях большинством предприятий. Приводятся некоторые математические модели, используемые при расчете графиков
прокатки, для таких задач в иностранной литературе приняты названия "hot strip mill planning" и
HRBPPs (hot rolling batch planning problems).
\newline
Приводимые в работах модели представляют собой аналоги и обобщения
задач коммивояжера TSP (Travelling Salesman Problem) и  планирования маршрутов транспорта VRT
(vehicle routing problem, \cite{BeVaLe_Dantzig_Ramser}).
Существуют модели PCTSP (Prize Collecting TSP), предложенная Балашом (\cite{BeVaLe_PCTSP_Balas}, \cite{BeVaLe_Bals}) и PCVRP
(Prize Collecting VRP, \cite{BeVaLe_Liu}), в которых для каждой пары партий прокатки задана стоимость перехода с
одной на другую, то есть стоимость того, что в графике прокатки они непосредственно следуют друг за другом.
Также задается награда (приз) за то, что партия входит в построенный график прокатки, и возможнен штраф за невхождение партии в
график прокатки. Результатом является построение графиков с максимизацией получаемых призов, за вычетом штрафов за переходы с одной партии на другую.
\newline Указанные задачи являются в общем случае труднорешаемыми.

Учитывая специфичный способ описания ограничений предшествования партий в графике прокатки, принятый
на отечественных предприятиях (например, ОАО "ММК"), ограничения удобно представлять в виде ориентированного графа. Предлагается удалить из целевой функции составляющую штрафов за переход, а сами переходы отнести в состав ограничений.
Таким образом, задача построения графиков прокатки в своих базовых ограничениях сводится к задаче поиска простой цепи достаточно большого веса в вершинно-взвешенном ориентированном графе. Смежность узлов в этом графе задается соотношением между ширинами и толщинами последовательно
прокатываемых партий.
\newline Основным результатом является то, что благодаря такому способу задания смежности удается построить алгоритм для нахождения простой цепи (графика прокатки) максимального веса, сложность которого ограничена кубом числа узлов (партий). Хотя в общем случае задача поиска
простой цепи максимального веса труднорешаема.
\newline Созданный алгоритм используется для оперативного планирования на станах прокатки в некоторых цехах ОАО "ММК".

Поясним причину выбора критерия оптимизации. Оценки графиков прокатки связаны с особенностями организации
производства на конкретном предприятии. Вместе с тем общим является то, что график прокатки должен содержать
достаточно таких партий, чтобы суммарный вес/длина партий были достаточно велики. Более того, наличие "большого"
технологически допустимого графика прокатки позволяет на следующем этапе в автоматическом или ручном режиме его
отредактировать, чтобы получить желаемый результат по всей совокупности практических требований. Также в качестве
веса партии может выступать величина, характеризующая не только ее физические характеристики, но и предпочтительность
по срокам, видам продукции и т.п. По указанным причинам для получения оптимизационной постановки задачи естественно
потребовать максимальности суммарного веса партий, входящих в график прокатки.

\newpage

\chapter{Постановка задачи}
\label{formulation}
Обозначим через $P$ множество партий $\{p_1, p_2, \dots, p_k\}$, где $k \in \mathbb{N}$.
\newline
Пусть

\begin{itemize}
\item $w: P \rightarrow \mathbb{R}^+$ --- ширина партии;
\item $t: P \rightarrow \mathbb{R}^+$ --- толщина партии;
\item $l: P \rightarrow \mathbb{R}^+$ --- длина партии; Для удобства в дальнейшем будем называть её весом, таким образом, $l$ --- весовая функция.
\item $r: \mathbb{R}^+ \rightarrow \mathbb{R}^+$ --- монотонно неубывающая функция, определяющая максимальную величину допустимой разности значений толщины между двумя соседними партиями;
\item $\mathbb{W} \in \mathbb{R}^+$ --- величина, определяющая максимальную величину допустимой разности значений ширины между двумя соседними партиями.
\end{itemize}

Геометрические параметры партий являются основным источником накладываемых ограничений на порядок следования партий друг за другом в графике прокатки.
\newline
Партия $q$ может непосредственно следовать за партией $p$ в графике прокатки в том и только в том случае, когда выполнены:
\begin{enumerate}
\item ограничение "для перехода по толщине":
\begin{equation}\label{width_constr} |t_p - t_q| \le \min\{r(t_p), r(t_q)\} \end{equation}

\item ограничение "для перехода по ширине":
\begin{equation}\label{thick_constr} 0 \le w_p - w_q \le \mathbb{W} \end{equation}

\end{enumerate}

Пусть $G$ ориентированный граф на множестве узлов $P$ с множеством дуг $E \subseteq P\times P$ таким, что
$pq \in E$ в том и только в том случае, когда партии $p$ и $q$ различны, и $q$ может непосредственно следовать
за $p$ в графике прокатки.

Множество всех допустимых графиков прокатки совпадает со множеством $\mathbb{B}(G)$ всех простых цепей в $G$.

Для простой цепи $z$ через $l(z)$ обозначим её вес:

\begin{equation}\label{path_weight} l(z) \triangleq \displaystyle\sum_{p \in P(z)} l(p) \end{equation}

Сформулируем {\bf задачу} оптимизации --- найти в $\mathbb{B}(G)$ цепь максимального веса:

\begin{equation} \label{problem} l(z) \rightarrow \displaystyle \max \mbox{, где} \;z \in \mathbb{B}(G) \end{equation}

\vspace{5pt}

Пусть $p$ - произвольный узел в $G$. Обозначим через:
\begin{itemize}
\item $In(p)$ --- множество узлов $q$ таких, что дуга $qp \in E$
\\ $|In(p)|$ --- входящая валентность узла $p$
\item $In^{+}(p) = \{q \in In(p) | w_q > w_p\}$
\item $Out(p)$ --- множество узлов $q$ таких, что дуга $pq \in E$
\\ $|Out(p)|$ --- исходящая валентность узла $p$
\item $Succ(p)$ --- множество всех узлов $q$, для которых существует ориентированный путь $pq$ в графе $G$. Из
общей теории графов известно, что в этом случае также существует и простая цепь из $p$ в $q$.
\item $Pred(p)$ --- множество всех узлов $q$, для которых существует ориентированный путь из $q$ в $p$ в графе $G$.
Отметим, что в этом случае также существует и простая цепь из $q$ в $p$.
\item $W = \{w_p| p \in P\}$ --- всевозможные значения ширин узлов
\item $P_w = \{p | w_p = w\}$, где $w \in W$, --- множество узлов, имеющих данную ширину $w$.
\item $G_w$ --- граф, индуцированный множеством $P_w$.
\end{itemize}


Заметим, что любая наибольшая по весу простая цепь является максимальной по включению узлов. Поэтому для решения задачи \ref{problem} достаточно искать наибольшую по весу цепь среди максимальных по включению узлов цепей.

\newpage

\chapter{Метод решения}
\label{method}
Для эффективного решения задачи предложен следующий подход:
\begin{enumerate}
\item Разрабатывается алгоритм, состоящий из двух частей - алгоритм, решающий задачу \ref{problem} в подграфах $G_w$ и общий алгоритм, решающий задачу \ref{problem} в графе $G$. В настоящей работе рассматривается общий алгоритм, использующий частный алгоритм  для подграфов (частный алгоритм описан в \cite{svLeon})в качестве подпрограммы.

\item Описывается способ оптимизации работы алгоритма. Предлагается подавать на вход алгоритма подграф $G'$ графа $G$ с тем же множеством узлов, что и у $G$, имеющий то же множество максимальных по включению цепей, что и в исходном графе. Нетрудно видеть, что в частности можно взять $G' = G$.
    \newline Предлагается эффективная конструкция графа $G'$, позволяющая существенно снизить время работы алгоритма.

\item Проводится анализ сложности алгоритма.

\item Приводятся результаты тестов и их анализ.
\end{enumerate}

\newpage

\chapter{Общий алгоритм поиска цепи максимального веса}
\label{algorytm}
\section{Анализ структуры графа}
\label{analys}
Для лучшего понимания структуры графа и удобства разработки алгоритма придуман удобный и естественный способ укладки графа на плоскости. Геометрические характеристики узлов выступают в роли координат. Для визуализации разработан плагин укладки для открытой программы Gephi \cite{Gephi}.

\begin{figure}[h!]
\centering
\includegraphics[width=320px]{graph_fragment.png}
\caption{Структура графа}
\label{graph_fragment}
\end{figure}
На рис. (\ref{graph_fragment}) изображен фрагмент графа.

По оси абсцисс откладывается толщина узлов, по оси ординат откладывается ширина узлов, начало координат находится в левом нижнем углу.
Видно, что граф складывается из подграфов $G_w$ таким образом, что дуги между подграфами направлены только вниз. Это обеспечивается условием предшествования партий по ширине. Внутри любого подграфа $G_w$ для каждой пары вершин $p, q \in P_w$ из существования дуги $pq$ следует существование обратной дуги $qp$. Эта симметрия обеспечивается модулем в условии предшествования по толщине. В данной работе мы рассмотрим алгоритм для решения задачи в $G$ c использованием готового алгоритма для решения задачи в подграфе $G_w$.

\newpage

\section{Неформальное описание алгоритма}
\label{no_formal}
Идея общего алгоритма основывается на принципе динамического программирования и заключается в постепенном решении задачи "сверху вниз". Для каждого узла в каждом подграфе последовательно строятся максимальные по весу цепи, заканчивающиеся в данном узле, вместе с тем из них выбирается максимум.
\\Частный алгоритм для каждой пары узлов $p$ и $q$ в подграфе $G_w$ предъявляет простую цепь максимального веса начинающуюся в $p$ и заканчивающуюся в $q$ (либо указывает, что не существует маршрута соединяющего $p$ и $q$).
\\Обозначим такую цепь $H_{pq}$. Тогда очевидно, что
\begin{equation} \displaystyle \max_{p,q \in P_w}  \{H|H=H_{pq}\}
\end{equation}
это решение задачи \ref{problem} в $G_w$.
\\
Рассмотрим случай, когда $G$ состоит из двух подграфов $G_{w_0}$ и $G_{w_1}$, что $w_0 > w_1$.
Заметим, что $\forall p \in P(G_{w_0}) $  $In^{+}(p) = \varnothing$.
\\Таким образом для простой цепи $H = p \rightarrow v_1 \rightarrow \ldots \rightarrow v_n \rightarrow q$, являющейся решением задачи возможны следующие варианты.
\begin{enumerate}
\item $p,q \in P(G_{w_0})$ и $\forall i = \overline{1, n} $ $v_i \in P(G_{w_0})$

\item $p,q \in P(G_{w_1})$ и $\forall i = \overline{1, n} $ $ v_i \in P(G_{w_1})$

\item $p \in P(G_{w_0}), q \in P(G_{w_1})$ и $\exists k $ $ 0 \le k \le n$ такое, что:
\end{enumerate}
$$
\begin{cases}
v_i \in P(G_{w_0}),&\text{если $1 \le i \le k$;}\\
v_i \in P(G_{w_1}),&\text{если $k < i \le n$.}
\end{cases}
$$
Варианты 1 и 2 означают, что цепь целиком лежит в каком-то одном подграфе. Третий вариант означает, что часть узлов цепи находится в одном подграфе, а часть в другом. Здесь удобно ввести вспомогательное понятие.
\begin{definition} Для двух произвольных простых цепей $H_1 = p_1 \rightarrow p_2 \rightarrow \ldots \rightarrow p_n$ и
$H_2 = q_1 \rightarrow q_2 \rightarrow \ldots \rightarrow q_m$, не имеющих общих узлов и таких, что $p_nq_1 \in E$,
\\{\bf суммой} этих цепей назовем цепь
$H = p_1  \rightarrow \ldots \rightarrow p_n \rightarrow q_1 \rightarrow \ldots \rightarrow q_m$
\\Обозначим $H = H_1 + H_2$.
\end{definition}
Таким образом вариант 3 означает, что решение является суммой двух цепей, каждая из которых лежит в своем подграфе.



Будем действовать следующим образом:
\\ Для каждого узла $p \in P(G_{w_0})$ переберем все узлы $s \in P(G_{w_0})$, каждый раз определяя $H_{sp}$ простую цепь максимального веса, соединяющую эти узлы, лежащую в $G_{w_0}$.
\\ Обозначим через $H[p] = \displaystyle \max_{s} \{H|H=H_{sp}\}$ --- максимальную по весу простую цепь, оканчивающуюся узлом $p$.
\\ На нулевом шаге максимальной простой цепью в $G$ является
\begin{equation} H_{max} = \displaystyle \max_{p} \{H|H=H[p]\}
\end{equation}
\\ Выберем и зафиксируем в $G_{w_1}$ узел $t$. Выберем в $G_{w_1}$ еще один узел $q$, возможно тот же самый.
\\ $H_{qt}$ -- простая цепь максимального веса, соединяющая эти узлы, лежащая в $G_1$.
\\ Если  $In^{+}(q) = \varnothing$, то полагаем $H[t] = \max \{H_{qt}, H[t]\} $.
\\ В противном случае просмотрим узлы $p \in In^{+}(q)$. Для каждого из них на предыдущем шаге уже рассчитаны максимальные по весу цепи $H[p]$.
\\Выберем такой узел $p$, у которого $l(H[p])$ максимальна.
\\ Сконструируем сумму $H_{ptq} = H[p] + H_{qt}$. Положим $H[t] = \max \{H_{ptq}, H[t]\} $.
\\ Решением задачи в исходном графе $G$ будет
\begin{equation} H_{max} = \max \{ \displaystyle \max_{t} \{H[t] \}, H_{max} \}
\end{equation}

Понятно, что описанный подход работает и в случае, когда исходный граф состоит из многих подграфов. Нужно обрабатывать подграфы в порядке  убывания ширин входящих в них узлов. После n-ого шага максимальные цепи уже рассчитаны в первых n подграфах, выбирается следующий подграф, в нём строятся цепи, соединяющие всевозможные пары узлов, они комбинируются с рассчитанными ранее цепями и результат передаётся на следующий шаг.

\begin{figure}[h!]
\centering
\includegraphics[width=420px]{algo.png}
\caption{Работа алгоритма}
\label{algo}
\end{figure}
На рис. (\ref{algo}) изображены узлы, из которых состоят подграфы $G_{w_0}$ и $G_{w_1}$.
\\Пунктиром изображена простая цепь $H_{qt}$.
\newpage

\section{Формальное описание алгоритма}
\label{formal}
Обозначим алгоритм $\mathbb{A}$ -- частный алгоритм, решает задачу \ref{problem} в подграфе $G_w$.
\\Алгоритм $\mathbb{A}$ для заданной пары узлов $s,\;t$ возвращает упорядоченный набор 
\\ $H = (p_1, p_2, \ldots, p_n)$, что $s = p_1 \rightarrow p_2 \rightarrow \ldots \rightarrow p_n = t$ - максимальная по весу 
\\ простая $(s, t)$ - цепь для заданной ширины $w$, или сообщение, что такую цепь построить нельзя.
\\Обозначим:
\begin{itemize}
\item $w_0, w_1, \ldots, w_z$ - всевозможные значения ширины, упорядоченные по убыванию.
\item $n_0, n_1, \ldots, n_z$ - количество узлов в соответствующих подграфах.
\end{itemize}
{\bf Общий алгоритм:}
\begin{enumerate}
\item На нулевом шаге

    \begin{itemize}

    \item $P_{w_0} := \{p^0_1, p^0_2, \ldots, p^0_{n_0}\}$.

    \item $\forall r = \overline{1, {n_0}}, \forall k = \overline{1, {n_0}}$ : $H^{0}_{rk}$ - максимальная по весу простая цепь,
соединяющая $p^0_r$ и $p^0_k$, построенная алгоритмом $\mathbb{A}$.

    \item $\forall m = \overline{1, {n_0}} : H[p^0_m] := \arg \displaystyle\max_{r = \overline{1, {n_0}}} l(H^{0}_{rm})$ -
    максимальная по весу простая цепь заканчивающаяся узлом $p^0_m$.

    \item $H^0 := \arg \displaystyle \max_{m = \overline{1, {n_0}}} l(H[p^0_m])$.

    \end{itemize}

\item На $i$-ом шаге

    \begin{itemize}

    \item $P_{w_i} := \{p^i_1, p^i_2, \ldots, p^i_{n_i}\}$.

    \item $\forall r = \overline{1, {n_i}}, \forall k = \overline{1, {n_i}}$ : $H^{i}_{rk}$ - максимальная по весу простая цепь из $p^i_r$ в $p^i_k$, построенная алгоритмом $\mathbb{A}$.

    \item $\forall r = \overline{1, {n_i}}$: $H^i_r := \displaystyle \arg \max_{ p \in In^+(p^i_r)} l(H[p])$ - максимальная по весу простая цепь, заканчивающаяся одним из узлов-предшественников узла $p^i_r$.

    \item $\forall m = \overline{1, {n_i}}$: $H[p^i_m] := \displaystyle \arg \max_{r = \overline{1, {n_i}}} l(H^i_r + H^i_{rm})$

    \item $H^i := \arg \max \{l(H^{i-1}), l(H[p^i_1]), \ldots , l(H[p^i_{n_i}])\}$.

    \end{itemize}

\item $H = H^z$ - максимальная по весу простая цепь в графе $G$.

\end{enumerate}

\begin{theorem}[{\bf1}] {\bf Общий алгоритм} строит максимальную по весу простую цепь.
\end{theorem}
\begin{proof}
Докажем, что для любого узла $p$ построенная алгоритмом простая цепь $H[p]$ является максимальной по весу.
Проведем доказательство методом математической индукции по номеру подграфа, в который входит узел $p$.


{\it База индукции}. Пусть $p$ такой, что $w_p = w_0$. На нулевом шаге алгоритм строит максимальные по весу простые цепи в $G_{w_0}$
в силу теоремы 1 работы \cite{svLeon}.

{\it Шаг индукции}. Пусть $\forall i \le k$, $\forall p \in P_{w_i}$: $H[p]$ - максимальная по весу простая цепь, оканчивающаяся узлом $p$. \\Докажем, что $\forall q \in P_{w_{k+1}}$ : $H[q]$ - максимальная по весу простая цепь с концом в $q$.

Пусть $q \in P_{w_{k+1}}$, $H[q]$ - цепь, построенная по общему алгоритму.

Пусть также $M$ - максимальная по весу простая цепь с концом в $q$.

Предположим, что $l(M) > l(H[q])$.

\vspace{40pt}

\begin{equation} H[q] = p_1 \rightarrow \ldots \rightarrow  p_l \rightarrow  p_{l+1} \rightarrow  \ldots p_{s} \rightarrow q
\end{equation}

где $w_{p_i} > w_{p_j} = w_{q}$ по всем $i \in \overline{1, l}, j \in \overline{l+1, s}$.

\begin{equation} M = q_1 \rightarrow \ldots \rightarrow q_m \rightarrow q_{m+1} \rightarrow  \ldots \rightarrow q_{t} \rightarrow q
\end{equation}

где $w_{q_i} > w_{q_j} = w_{q}$ по всем $i \in \overline{1, m}, j \in \overline{m+1, t}$.


Тогда

\begin{equation} l(H[q]) = l(p_1 \ldots p_l) + l(p_{l+1} \ldots p_{s}) + l(q)
\end{equation}

и

\begin{equation} l(M) = l(q_1 \ldots q_m) + l(q_{m+1} \ldots q_{t}) + l(q)
\end{equation}

Рассмотрим цепь $M$. По предположению индукции $l(H[q_m]) \ge l(q_1 \ldots q_m)$.

Пусть $h$ - максимальная по весу простая цепь, соединяющая $q_{m+1}$ и $q$, построенная алгоритмом $\mathbb{A}$.

Тогда

\begin{equation} \label{pr1} l(H[q]) \ge l(H[q_m]) + l(h) \ge \end{equation}

Неравенство \ref{pr1} выполняется по построению $H[q]$ (т.к. перебираются всевозможные такие суммы цепей, лежащих в подграфах $G_{w_i}$ и подграфе $G_{w_{k+1}}$).

А т.к. h - максимальна по весу, то выполняется

\begin{equation} \ge l(H[q_m]) + l(q_{m+1} \ldots q_{t}) + l(q) \ge l(q_1 \ldots q_m) + l(q_{m+1} \ldots q_{t}) + l(q) = l(M)
\end{equation}

Получается, что предположение не верно, и на самом деле $L(M) \le l(H[q])$, 
\\ а т.к. $M$ максимальная по весу, то
таким образом и $H[q]$ максимальная по весу простая цепь, заканчивающаяся в $q$.

\end{proof}

\begin{theorem}[{\bf2}]
Общий алгоритм имеет сложность $O(k^3)$, где $k = |P|$.
\end{theorem}
\begin{proof}
Пусть $n_i = |P_{w_i}|$, $m = |W|$. Алгоритм производит $m$ итераций по количеству различных значений ширины узлов.
При построении максимальной цепи для двух фиксированных узлов, алгоритм в худшем случае
просматривает один раз отсортированный по толщине список узлов в данной ширине. То есть,
на каждом шаге список узлов сортируется за $n_i\log n_i$, после чего перебираются попарно
узлы ($n_i^2$) и для них строится максимальный путь ($n$) \cite{svLeon}, и для каждого узла перебирается список его предшественников.

Тогда сложность общего алгоритма не превосходит
\begin{equation} C (\displaystyle\sum_{i=1}^{m}(\sum_{p\in P_{w_i}} |In^{+}(p)| + n_i\log n_i + n_i^3))
\end{equation}
где $C$ --- некоторая константа, что в худшем случае, когда все узлы находятся в одной ширине есть $O(k^3)$.
\end{proof}

\newpage

\section{Оптимизация работы алгоритма. \\Построение графа $G'$}
\label{cleaning}
Обозначим $\bar{G}$ - граф, полученный из исходного графа $G$ удалением дуг $pq$, для которых существует путь
$H = p \rightarrow p' \rightarrow \ldots \rightarrow p'' \rightarrow q$ такой, что $w_p > w_{p'}$ и $w_{p''} > w_q$.

\begin{theorem}[{\bf3}] Граф $\bar{G}$ содержит все максимальные по включению узлов цепи графа $G$.
\end{theorem}
\begin{proof}
Пусть $H_m$ --- некоторая максимальная по включению цепь в графе $G$. Предположим, что $H_m$ не содержится в $\bar{G}$.
То есть существует хотя бы одна дуга $pq \in H_m$, которая не содержится в $E(\bar{G})$.
\\ Раз эта дуга была удалена из графа $G$, следовательно, для этой дуги существует путь
$H = p \rightarrow p' \rightarrow \ldots \rightarrow p'' \rightarrow q$ в графе $G$,
\\где $w_p > w_{p'}$ и $w_{p''} > w_q$. Это условие противоречит
максимальности цепи $H_m$. Следовательно, любая максимальная цепь графа $G$ содержится в графе $\bar{G}$.
\end{proof}

Таким образом, в качестве $G'$ можно взять граф $\bar{G}$.

\subsection*{Иллюстрация "чистки" графа}
\begin{figure}[h!]
\centering
\includegraphics[width=420px]{not_clear.png}
\caption{Исходный граф $G$}
\label{not_clear}
\end{figure}
На рис. (\ref{not_clear}) изображен фрагмент исходного графа, в котором порядка 340 узлов и 17000 дуг.

\vspace{100pt}

\begin{figure}[h!]
\centering
\includegraphics[width=420px]{clear.png}
\caption{"Чищенный" граф $G'$}
\label{clear}
\end{figure}
На рис. (\ref{clear}) изображен фрагмент соответствующего "чищенного" графа.
\\ В нем то же количество узлов, но после "чистки" остаётся порядка 3900 дуг.
\\ Обратим внимание, что удаляются только лишь некоторые дуги, соединяющие узлы, имеющие разную ширину.
\\ Поэтому легко придумать пример, когда построение такого графа не даст выигрыша в работе алгоритма, но на реальных данных процедура чистки оказывается эффективной.
\newpage

\chapter{Программная реализация}
\label{program}
В работе использован язык программирования Java.

\section{Описание кода программы}
\subsection{Типы данных}
\begin{itemize}
\item Вводим класс для представления узлов графа:
\\class Vertex \{
    ...

{\parindent=1cm double width;}

{\parindent=1cm	double thickness;}

{\parindent=1cm	double length;}
\\   ... \}
\\ где width, thick - геометрические параметры партии, а length - длина (вес).
\item Класс для представления ограничений:
\\ class Crit \{
	...

{\parindent=1cm	double w;}

{\parindent=1cm  double r(double thickness) \{...\}}
\\  ... \}
\\ где число w соответствует ограничению \ref{width_constr}, а метод r(double) соответствует ограничению \ref{thick_constr} из главы \ref{formulation}.
\item Класс для представления дуг графа:
\\class Edge \{
    ...

{\parindent=1cm	Vertex from;}

{\parindent=1cm	Vertex to;}
\\   ...\}
\item Создаём класс для представления графа:
\\ \indent  class Graph \{
    ...

{\parindent=1cm		ArrayList<Vertex> vertex;}

{\parindent=1cm		ArrayList<Edge> edges;}

{\parindent=1cm		ArrayList<ArrayList<Vertex$>>$ pred;}

{\parindent=1cm		ArrayList<ArrayList<Vertex$>>$ succ;}

{\parindent=1cm		ArrayList<ArrayList<Vertex$>>$ in;}

{\parindent=1cm		ArrayList<ArrayList<Vertex$>>$ out;}
\\   ... \}
\\ где списки in, out, pred, succ служат для представления множеств описанных в главе \ref{formulation}
(in соответствует множеству $In^+$), а length - суммарная длина (вес) цепи.
\item Класс для представления результата работы алгоритма - простой цепи:
\\class Path \{
    ...

{\parindent=1cm		Vertex start;}

{\parindent=1cm		Vertex end;}

{\parindent=1cm		ArrayList<Vertex> path;}

{\parindent=1cm		double length;}
\\  ... \}
\\ где в списке path хранится последовательность узлов цепи, начиная со start и заканчивая end.
\end{itemize}
\subsection{Методы}
\begin{itemize}
\item Основной метод решающий поставленную задачу(принимает на вход граф, возвращает простую цепь максимального веса):
\\ Path maxPath(Graph graph, Crit crit) \{

{\parindent=1cm	 ArrayList<Path> paths = new ArrayList<Path>(); {\small \emph{ /* объявляем массив, в котором будут строится максимальные цепи */}}}
\\ ...

{\parindent=1cm	 for (double w : widthList) \{ }

{\parindent=2cm	 ArrayList<Vertex> layer = layer(graph, w);}

{\parindent=2cm	 merge(graph, layer, paths, crit);}

{\parindent=1cm	 \}}

{\parindent=1cm	 return max(paths);}
\\ \}
\\ где ArrayList<double> widthList --- отсортированный по убыванию список всевозможных ширин узлов,
\\ а ArrayList<Vertex> layer --- соответствует подграфу $G_w$.
\item Метод для конструирования подграфа $G_w$ (принимает на вход граф и значение ширины, возвращает список узлов имеющих заданную ширину):
\\ ArrayList<Vertex> layer(Graph, double) \{...\}
\item Метод, производящий на каждом шаге слияние уже построенных цепей с цепями в следующем подграфе (вызывается в цикле в основном методе, результат накапливается в переменной paths):
\\ void merge(Graph graph, ArrayList<Vertex> layer,

{\parindent=4cm ArrayList<Path> paths, Crit crit) \{}
    ...

{\parindent=1cm		for (Vertex fixed : layer) \{ {\small \emph{/*выбираем в подграфе "фиксированную" вершину*/}}}

{\parindent=2cm			Path fixedPath = new Path();}

{\parindent=2cm			for (Vertex var : layer) \{ {\small \emph{/*перебираем в подграфе "свободные" вершины*/}}}

{\parindent=3cm             {\small \emph{/*в следующей строке используем частный алгоритм*/}}}

{\parindent=3cm				Path path = Path.sortedLayerPath(layer, fixed, var, crit); }

\medskip

{\parindent=2.8cm             {\small \emph{/*выбираем подходящую цепь-продолжение для "свободной" вершины*/}}}

{\parindent=3cm				Path maxTail = chooseTail(var, paths); }

{\parindent=3cm {\small \emph{/*сравниваем с текущим претендентом на максимальную цепь, }}}

{\parindent=3cm {\small \emph{заканчивающуюся в узле fixed*/}}}

{\parindent=3cm				maximize(path, maxTail, fixedPath); }

{\parindent=2cm			\}}

{\parindent=2cm {\small \emph{/*записываем результат в список уже рассчитанных цепей*/}}}

{\parindent=2cm			paths.set(fixed.id, fixedPath); }
\\ ... \}

\item Path sortedLayerPath(ArrayList<Vertex>, Vertex, Vertex, Сrit) \{...\} --- реализация частного алгоритма.
\item Path maximize(Path, Path, Path) \{...\} --- конструирует сумму первых двух аргументов, возвращает максимум из суммы и третьего аргумента.
\end{itemize}

\section{Результаты экспериментов}
Данные для тестов берутся из корпоративной сети ОАО "ММК". Обычно в распоряжении имеются выборки порядка 200-300 партий.
\begin{figure}[h!]
\centering
\includegraphics[width=420px]{clear_result.png}
\end{figure}

\begin{center} Табл. 5.1: Результаты тестов
\end{center} 

Реальные данные таковы, что обычно при больших выборках от 75\% процентов узлов попадают в построенную цепь. Это хороший с практической точки зрения результат, т.к. на производстве такие большие графики прокатки избыточны и построенную цепь можно дополнительно редактировать, добиваясь выполнения остальных технических ограничений, не упоминаемых в этой работе.


Так же отметим, что программа работает достаточно быстро, что важно, потому что в реальной жизни требуется многократный запуск алгоритма.
Видно, что скорость работы программы довольно сильно зависит от структуры конкретных начальных данных. Имеет значение соотношение между количеством подграфов в исходном графе и количеством входящих в них узлов. Например в случае, когда исходный граф состоит из малого числа подграфов, то время работы уменьшается за счет сокращения перебора дуг между подграфами(выборка 6).


(Тесты проводились на персональном компьютере).
\newpage


\section{Инструкция пользователю}
\label{instrution}
\begin{itemize}
\item {\bf Входной файл} должен иметь следующий формат:
\\ Список партий, заданных тремя числами --- шириной, толщиной и длиной (весом) партии.
\\ Пример:

{\parindent=2cm 1635	$\;$ 2,1 $\;$ 3,288}

{\parindent=2cm 1630 $\;$ 2,1 $\;$ 1,099}

{\parindent=2cm 1630 $\;$ 3,9 $\;$ 1,237}

{\parindent=2cm 1630 $\;$ 2,1 $\;$ 2,199}

{\parindent=2cm 1620 $\;$ 2,1 $\;$ 5,531}

{\parindent=2cm 1615 $\;$ 4,5 $\;$ 1,151}

{\parindent=2cm 1610 $\;$ 3,9 $\;$ 0,626}

{\parindent=2cm 1610 $\;$ 3,9 $\;$ 1,252}

{\parindent=2cm 1610 $\;$ 3,9 $\;$ 1,252}

{\parindent=2cm 1600 $\;$ 4,0 $\;$ 0,369}
\item {\bf Выходной файл} имеет следующий формат:
\\ Общий вес поданной выборки, вес построенной цепи, количество входящих в нее узлов, последовательность узлов, время работы в милисекундах.
\\ Пример:
\\ Total Weight: 18.004
\\ Path Weight: 12.117
\\ Path Size: 4
\\ $[[0 (1635.0;2.1;3.288)], [1 (1630.0;2.1;1.099)], [3 (1630.0;2.1;2,199)], [4 (1620.0;2.1;5,531)]]$
\\ Time: 1
\end{itemize}
\newpage


\chapter*{Заключение}
\addcontentsline{toc}{chapter}{Заключение}
\label{conclusion}
Автоматическое планирование металлургического производства является сложной задачей, которая до сих пор не реализована полностью ни на одном предприятии в мире. Сопутствующие ей математические постановки зачастую являются труднорешаемыми. За счет исследования технологических ограничений на конкретном предприятии удалось сформулировать математическую задачу планирования графика прокатки. Удалось разработать полиномиальный алгоритм её решения. Результат уже частично внедрён и продолжается внедрятся на ОАО "ММК". В реальной жизни существуют более общие и сложные постановки задачи планирования графиков прокатки, решение которых основывается на описанных в настоящей работе алгоритмах.
\newpage

\small

\addcontentsline{toc}{chapter}{Список литературы}
\begin{thebibliography}{50}
\bibitem{svLeon} Леонова С.И. Разработка и исследование алгоритмов построения экстремальных цепей в вершинно-взвешенных орграфах. Частный алгоритм. 2014
\bibitem{BeVaLe_ReviewStellProduction} Lixin Tang, Jiyin Liu, Aiying Rong, Zihou Yang. A review of
planning and scheduling systems and methods for integrated steel production. European Journal of
Operational Research. Volume 133, Issue 1, 16 August 2001, PP. 1–20.
\bibitem{BeVaLe_IntegrContCasterAndRolling} P. Cowling, W. Rezig. Integration of continuous caster and hot strip
mill planning for steel production. Journal of Scheduling, Volume 3, Issue 4, July/August 2000, PP. 185–208.
\bibitem{BeVaLe_PCTSP_Balas} E. Balas, The prize collecting travelling salesman problem, Networks 19 (1989) 621-636.
\bibitem{BeVaLe_Bals} E. Balas and H. M. Clarence. Combinatorial optimization in steel rolling.
Workshop on Combinatorial Optimization in Science and Technology, April, 1991.
\bibitem{BeVaLe_Liu} Shixin Liu. Model and Algorithm for Hot Rolling Batch Planning in Steel Plants.
International Journal of Information and Management Sciences. 21 (2010), PP. 247-263.
\bibitem{BeVaLe_Dantzig_Ramser} G. B. Dantzig and J. H. Ramser. Management Science, Vol. 6, No. 1 (Oct., 1959), pp. 80-91.
\bibitem{BeVaLe_PCVRP_MDep_NLCost} Andreas Stenger, Michael Schneider, Dominik Goeke.
The prize-collecting vehicle routing problem with single and multiple depots and non-linear cost.
EURO Journal on Transportation and Logistics, May 2013, Volume 2, Issue 1-2, pp 57-87.
\bibitem{BeVaLe_Coco} K. Ioannidou, S. D. Nikolopoulos. The Longest Path Problem is Polynomial on
Cocomparability Graphs. Algorithmica. January 2013, Volume 65, Issue 1, pp 177-205.
\bibitem{Gephi} The Open Graph Viz Platform [Офиц. сайт]. URL: http://gephi.org/ (дата обращения: 01.06.2014)

\end{thebibliography}

\newpage

\chapter*{Приложение}
\addcontentsline{toc}{chapter}{Приложение}
\label{app}


\section*{Пример исходного кода}
\begin{figure}[h!]
\centering
\includegraphics[width=420px]{1.png}
\end{figure}
\begin{figure}[h!]
\centering
\includegraphics[width=420px]{2.png}
\end{figure}
\begin{figure}[h!]
\centering
\includegraphics[width=420px]{3.png}
\end{figure}


\end{document} 